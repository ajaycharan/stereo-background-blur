close all
clear
clc

% Load rectified images - Colour and Grayscale
RECT_LEFT_BW = imread('D:\TestFocus\Rectified\Focus\LEFT\left_rectifiedFrame0000001.png');
RECT_RIGHT_BW = imread('D:\TestFocus\Rectified\Focus\RIGHT\right_rectifiedFrame0000001.png');
RECT_LEFT_CLR = imread('D:\TestFocus\Rectified\Focus\leftCLR_rectifiedFrame0000001.png');
RECT_RIGHT_CLR = imread('D:\TestFocus\Rectified\Focus\rightCLR_rectifiedFrame0000001.png');


% Load the depth map corresponding to the rectified image
NUMPY_LOC = 'D:\TestFocus\Rectified\Focus\NUMPY\depth_test1000000.npy';
DEPTH = readNPY(NUMPY_LOC);

% Created the background image - blurred image
H = fspecial('disk',20);
blurredImage = imfilter(RECT_LEFT_CLR,H,'replicate');

% Unroll both colour and blurred images into vectors
colour_image_vec = reshape(RECT_LEFT_CLR,[size(DEPTH,1)*size(DEPTH,2),3]);
blurred_image_vec = reshape(blurredImage,[size(DEPTH,1)*size(DEPTH,2),3]);

% Use K-Means to segment out the depth image into
% nDepths = 4;
% ab = reshape(DEPTH,[size(DEPTH,1)*size(DEPTH,2),1]);
% [cluster_idx, cluster_center] = kmeans(ab,nDepths,'distance','sqEuclidean','Replicates',3);
% pixel_labels = reshape(cluster_idx,[size(DEPTH,1),size(DEPTH,2)]);
% save('kmeansresult.mat',pixel_labels);
% figure,
% imshow(pixel_labels,[]);
segdata = load('kmeansresult.mat');
pixel_labels = segdata.pixel_labels;

% Create a mask of all pixels at the prescribed depth (usually the max
% disparity -> minimum depth)
mask = zeros(size(DEPTH,1)*size(DEPTH,2),1);
indices = find(pixel_labels == max(max(pixel_labels)));
mask(indices) = 1;
mask = reshape(mask,[size(DEPTH,1),size(DEPTH,2)]);

% Perform a few morphological operations to create a more uniform mask
mask = imfill(mask,'holes');
mask = bwmorph(mask,'clean');
mask = bwmorph(mask,'open',11);
mask = bwmorph(mask,'close',10);
mask = bwmorph(mask,'thicken',3);

% Extract the largest connected component
mask = bwareafilt(mask, 1, 'largest');
mask = imfill(mask,'holes');
mask = bwmorph(mask,'spur',25);

st = regionprops(mask,'BoundingBox');
width = st.BoundingBox(3);
height = st.BoundingBox(4);
row_start = st.BoundingBox(2);
col_start = st.BoundingBox(1);
row_end = row_start + height;
col_end = col_start + width;

padding = 30;
T = mask(row_start-padding:row_end+padding,col_start-padding:col_end+padding);
figure,
imagesc(T);

DD = bwdist(T);
figure,
imagesc(DD);

% Create a distance transform matrix from the mask outward
D = bwdist(mask_crop);
% Standardize the distance transform to create a gradient
maxD = max(max(D));
minD = min(min(D));
mean = mean2(D);
normDistTransVec = (D - minD)/(maxD-minD);
newmask = ones(
Evec = reshape(normDistTransVec,[size(normDistTransVec,1)*size(normDistTransVec,2),1]);
gradient = [Evec,Evec,Evec];

% Apply the gradient onto the image
resultingImageVec = double(gradient).*double(blurred_image_vec) + double(1-gradient).*double(colour_image_vec);
resImage = reshape(resultingImage,[size(DEPTH,1),size(DEPTH,2),3]);



figure,
imshow(uint8(resImage));

figure,
imshow(reshape(colour_image_vec,[size(DEPTH,1),size(DEPTH,2),3]));




